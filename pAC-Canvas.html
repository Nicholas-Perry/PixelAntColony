<!DOCTYPE html>
<html lang="en" style="width:100%">
	<head>
	<meta charset="utf-8" />
	<title>Pixel Ant Colony</title>
		
	<link href='https://fonts.googleapis.com/css?family=Press+Start+2P' rel='stylesheet' type='text/css'>
	
	<style>
			
	* { margin:0; padding:0; } /* to remove the top and left whitespace */
	html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
	canvas { display:block; } /* To remove the scrollbars */
	
	html, body {
		padding:0;
		margin:0;
		
		
		font-family: 'Press Start 2P', cursive;
		font-size:100%;
		font-size:0.875em; /* 16x.875=14 */
		
		line-height:1.125em; /* 16◊1.125=18 */
	}
	
	h1,h2,h3,h4,h5,h6 {
		line-height:1.125em; /* 16◊1.125=18 */
	
	}
	
	
	
	h1 {
		text-align:center;
	}
	
	#right-controls,#left-controls {
		display: block;
		
		margin: 0 auto;
		
		border: 1 solid #000000;
	}
	#right-controls {
		float:right;
	}
	#left-controls {
		float:left;
	}
	
	#right-controls > div {
		display:block;
		float:right;
		border: 1px solid #FF0000;
	}
	
	.control-set > button {
		min-width:0.36in;
		min-height:0.36in;
			font-family: 'Press Start 2P', cursive;
	}
	
	.display {
		display:block;
		min-width:1024px;
		width:100%;
		text-align:justify
		float:right;
		z-index:0;
	}
	
	#gameworld,	
	#bottomControls {
		display: block;
		margin: 0 auto;
		width:800px;
		border: 1 solid #000000;
	}
	
	
	</style>
</head>
<body>



<div>
	<div id='left-controls'>
		
	</div>
	<div id='right-controls'>
		<div class="control-set">
			Canvas Size:<hr/>
			<button onclick="canvasSize(400,400)">Small</button>
			<button onclick="canvasSize(800,800)">Medium</button><br/>
			<button onclick="canvasSize(1900,900)">Large</button>
			<button onclick="canvasSize(window.innerWidth-20,window.innerHeight-150)">Max</button>
			<br/><br/>
			<hr/>
W:<input type="number" min="100" max="1920" size="4" step="20" name="height" value="400"/> x
H:<input type="number" min="100" max="1200" size="4" step="20" name="width" value="400"/><br/><br/>
<button onclick="canvasSize(document.getElementsByName('width')[0].value,document.getElementsByName('height')[0].value)">Set Custom</button>

		</div>
		
		<div class="control-set">
			Random<hr/>
			<button onclick="reroll()">reroll!</button> <br/>
		</div>
		
		<div class="control-set">
			Play!<hr/>
			<button onclick="gameStart()">Go</button> <br/>
			<button onclick="gameStop()">Stop</button> <br/>
		</div>
		<hr/>
		<div class="control-set">
		<br/><hr/><br/>
		W:&nbsp;<span id="canvasWidth"></span> x H:&nbsp;<span id="canvasHeight"></span><br/>
		px:&nbsp;<span id="canvasPixelCount"></span><br/><br/>
		TICK:&nbsp;<span id="tickDisplay">[generation]</span><br/>
		FPS:&nbsp;<span id="framerateDisplay">[framerate]</span><br/>
		SPF:&nbsp;<span id="frametimeDisplay">[frametime]</span>ms
		</div>
	</div>
</div>


<h1>Pixel Ant Colony v1.0</h1>
<canvas id="gameworld" width="800" height="300"></canvas>



<script>
	
	

	// all this code is bad, do not look at it, its bad.
	
	var widthElem = document.getElementById('canvasWidth');
	var heightElem = document.getElementById('canvasHeight');
	var pixelCountDisplay =  document.getElementById('canvasPixelCount');
	var canvas = document.getElementById('gameworld');
	var context = canvas.getContext('2d');
	var canvasWidth  = canvas.width;
	var canvasHeight = canvas.height;
	var ctx = canvas.getContext('2d');
	var imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
		
	var buf = new ArrayBuffer(imageData.data.length);	// a liniar arraybuffer that stores the color data for the image.
	var buf8 = new Uint8ClampedArray(buf); 				// used to index into the bufer via 8bit ord
	var data = new Uint32Array(buf);					// used to index into the buffer via a 32 bit ord
	
	function render() {
		pixelGen();
		pushToCanvas();
		console.log("render");
	}
	
	function canvasSize(width,height) {
		
		console.log("setting canvas w:"+width+" h:"+height);
		
		// ajust canvas sizes
		canvas.width=width;
		canvas.height=height;
		canvas.style.width  = width+'px';
		canvas.style.height = height+'px';
		
		// ajust buffers 	
		canvasWidth  = canvas.width;
		canvasHeight = canvas.height;
		imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
		
		buf = new ArrayBuffer(imageData.data.length);
		buf8 = new Uint8ClampedArray(buf);
		data = new Uint32Array(buf);
		
		
		//display it
		widthElem.textContent	=	canvas.width;
		heightElem.textContent	=	canvas.height;
		pixelCountDisplay.textContent	=	canvas.width*canvas.height;
		
		render();
	}
	
	// Determine whether Uint32 is little- or big-endian.
	data[1] = 0x0a0b0c0d;
		
	function endiannessCheck() {
		var isLittleEndian = true;
		if (buf[4] === 0x0a && buf[5] === 0x0b && buf[6] === 0x0c &&
			buf[7] === 0x0d) {
			isLittleEndian = false;
		}
		return isLittleEndian;
	}
	
	var pixelGen = function () {
		// highspeed rendering method based on 
		// https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/
		console.log("choosing endianness");
		// first time in this function, we decide what call to really run
		if (endiannessCheck()) {
			console.log("setting to little endian");
			pixelGen = lePixelGen;
		} else {
			console.lgo("setting to beg endian");
			pixelGen = bePixelGen;
		}
		
		// now we call the real function
		pixelGen();
	};

	
	
	function lePixelGen() {
		console.log("Generate (little endianness)");
		for (var y = 0; y < canvasHeight; ++y) {
			for (var x = 0; x < canvasWidth; ++x) {
				var value = x * y & 0xff;
				
				data[y * canvasWidth + x] = random.uint32()
				
				/*
					(255   << 24) |    // alpha
					(value << 16) |    // blue
					(value <<  8) |    // green
					 value;            // red
				*/
			}
		}
		
	}
	
	function bePixelGen() {
		console.log("Generate (big endianness)");
		for (y = 0; y < canvasHeight; ++y) {
			for (x = 0; x < canvasWidth; ++x) {
				value = x * y & 0xff;

				data[y * canvasWidth + x] = random.uint32()
				
				/*
					(value << 24) |    // red
					(value << 16) |    // green
					(value <<  8) |    // blue
					 255;              // alpha
				*/
			}
		}
	}
	
	function pushToCanvas() {
		console.log("Drawing");
		imageData.data.set(buf8);
		ctx.putImageData(imageData, 0, 0);
	}

	function tick() {
		pixelGen();
	}


	function reroll() {
		pixelGen();
		pushToCanvas();
	}
	
	var start = false;
	var running = false;
	var frameCount = 0;
	
	
	function gameStart() {
		
		start = true;
		
		if(!running) {
			gameLoop(0);
		}
	}
	
	function gameStop() {
		start = false;
	}
	
	
	var tickDisplay = document.getElementById('tickDisplay');
	var framerateDisplay = document.getElementById('framerateDisplay');
	var frametimeDisplay = document.getElementById('frametimeDisplay');
	
	// fps calc from https://stackoverflow.com/questions/5078913/html5-canvas-performance-calculating-loops-frames-per-second
	var fps = 0,frametime=0, now, lastUpdate = (new Date)*1 - 1;
	// The higher this value, the less the FPS will be affected by quick changes
	// Setting this to 1 will show you the FPS of the last sampled frame only
	var fpsFilter = 5;
	var fpsUpdateInterval = 1000; // how often to update he displays, in ms
	
	function gameLoop(time) {

		tick();

		pushToCanvas();

		frameCount++;
		
		frametime = ((now=new Date) - lastUpdate)
		var thisFrameFPS = 1000 / frametime;
		fps += (thisFrameFPS - fps) / fpsFilter;
		lastUpdate = now * 1 - 1;
		
		
		if(start){
			running = true;
			window.requestAnimationFrame(gameLoop);
		}
		else {
			running = false;
			// game is not running
		}
		
		console.timeEnd("gameLoop()");
	}
	
	
	//this periodically updates the displays
	// should be rewritten to store in a timer management system so that I can set and clear it easier
	setInterval(function(){
	tickDisplay.innerHTML = frameCount;
		framerateDisplay.innerHTML = fps.toFixed(1) + "fps";
	}, fpsUpdateInterval);
	setInterval(function(){
		tickDisplay.innerHTML = frameCount;
	}, fpsUpdateInterval/10);
		setInterval(function(){
		frametimeDisplay.innerHTML = frametime;
	}, fpsUpdateInterval/10);
	
	
</script>

<script>
/* Fast random number generator with uint32 support*/
// From http://baagoe.com/en/RandomMusings/javascript/
// Johannes Baag√∏e <baagoe@baagoe.com>, 2010
function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  mash.version = 'Mash 0.9';
  return mash;
}

// From http://baagoe.com/en/RandomMusings/javascript/
function Alea() {
  return (function(args) {
    // Johannes Baag√∏e <baagoe@baagoe.com>, 2010
    var s0 = 0;
    var s1 = 0;
    var s2 = 0;
    var c = 1;

    if (args.length == 0) {
      args = [+new Date()];
    }
    var mash = Mash();
    s0 = mash(' ');
    s1 = mash(' ');
    s2 = mash(' ');

    for (var i = 0; i < args.length; i++) {
      s0 -= mash(args[i]);
      if (s0 < 0) {
        s0 += 1;
      }
      s1 -= mash(args[i]);
      if (s1 < 0) {
        s1 += 1;
      }
      s2 -= mash(args[i]);
      if (s2 < 0) {
        s2 += 1;
      }
    }
    mash = null;

    var random = function() {
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
      s0 = s1;
      s1 = s2;
      return s2 = t - (c = t | 0);
    };
    random.uint32 = function() {
      return random() * 0x100000000; // 2^32
    };
    random.fract53 = function() {
      return random() + 
        (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
    };
    random.version = 'Alea 0.9';
    random.args = args;
    return random;

  } (Array.prototype.slice.call(arguments)));
};

var random = Alea();
console.log(random());
console.log(random.uint32());

</script>

<script>
	canvasSize(400,400);
	
</script>


</body>

</html>